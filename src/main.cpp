#include <zephyr.h>
#include "ei_run_classifier.h"
#include "numpy.hpp"

static const float features[] = {
8.4192, -4.1599, -2.9245, 8.4168, -4.1264, -3.0167, 8.4348, -4.1922, -2.9509, 8.4252, -4.1312, -2.8910, 8.4240, -3.9133, -2.9257, 8.4240, -3.7314, -3.0191, 8.4360, -4.0941, -3.0191, 8.4527, -4.0773, -2.9916, 8.4252, -4.3287, -2.8946, 8.3905, -4.4065, -2.7234, 8.3785, -4.3981, -2.8084, 8.3689, -4.0642, -2.8718, 8.3869, -4.0043, -2.9544, 8.4336, -4.2186, -2.8419, 8.4324, -4.4029, -2.9054, 8.4025, -4.4436, -2.8311, 8.3701, -4.6519, -2.8060, 8.3677, -4.4029, -2.9616, 8.3821, -4.0869, -3.0191, 8.3582, -4.2234, -2.8946, 8.4791, -4.1240, -2.8886, 8.4420, -4.3347, -2.8575, 8.3845, -4.2401, -2.6025, 8.4025, -3.8451, -3.0311, 8.3821, -3.5279, -3.2717, 8.4503, -4.1743, -3.0610, 8.4599, -4.4197, -2.8683, 8.4575, -4.0426, -3.3088, 8.5102, -3.9744, -2.9951, 8.5425, -3.9014, -2.8647, 8.5641, -4.1300, -2.8611, 8.5832, -4.3706, -2.8671, 8.5892, -4.7034, -2.9568, 8.5569, -5.1870, -2.7138, 8.4970, -5.7305, -2.5546, 8.3977, -6.2261, -2.4505, 8.3306, -6.8642, -2.6468, 8.2624, -7.3179, -2.3523, 8.1199, -7.5717, -2.2494, 7.9308, -8.8155, -2.3284, 8.0050, -9.4020, -2.6552, 7.9942, -9.3290, -2.9425, 7.9140, -7.5298, -2.3140, 7.7728, -5.5390, -1.8340, 7.5860, -4.7178, -1.6293, 7.4160, -5.4396, -1.6173, 7.2149, -7.2927, -1.8100, 7.3155, -8.2971, -2.3966, 7.3526, -9.0106, -2.9078, 7.1874, -9.5086, -3.0837, 6.8079, -8.6610, -3.0574, 6.1986, -5.4025, -2.8527, 6.2991, -2.0830, -2.3703, 6.4380, -2.1009, -2.0255, 6.1854, -2.8695, -1.7705, 5.4887, -1.9620, -1.3324, 5.0206, 1.4736, -1.9980, 5.3067, 2.0267, -4.2329, 5.4396, 3.8702, -5.8335, 5.5342, 5.7329, -5.2469, 5.5294, 3.8427, -4.6567, 5.3929, 3.5674, -4.8662, 5.5522, 5.3738, -5.2277, 5.7245, 5.8514, -5.1475, 5.7341, 5.9029, -4.8351, 5.4612, 5.0985, -4.5322, 5.5150, 4.6448, -4.6651, 5.0578, 5.1930, -4.5957, 5.0566, 5.0482, -4.8135, 5.0721, 6.7995, -7.8051, 5.0961, 7.3885, -6.8606, 4.7477, 4.6256, -5.3223, 4.1695, 4.2521, -4.6483, 3.7242, 5.5510, -5.5905, 3.5949, 9.0992, -6.7983, 3.8439, 11.1977, -8.2373, 4.0893, 13.2555, -10.7200, 3.8726, 10.9942, -8.7149, 3.6703, 10.8876, -7.5860, 3.8044, 13.3477, -8.6981, 3.8475, 15.3911, -9.3182, 3.7242, 16.0759, -8.9411, 3.7469, 14.7758, -8.2672, 3.8235, 14.2587, -8.9184, 4.0821, 12.1530, -8.4515, 4.3814, 9.6498, -7.9164, 4.6603, 8.9603, -7.3227, 4.7896, 8.0924, -6.8654, 4.9500, 7.0234, -6.4392, 5.0757, 6.1160, -6.7552, 5.2601, 4.6160, -5.7712, 5.5976, 4.3730, -6.2537, 5.7269, 4.6615, -6.5410, 5.8634, 5.6132, -6.6798, 5.9687, 4.9129, -6.3758, 5.9245, 2.9700, -5.4600, 5.9819, 0.3160, -3.9361, 6.0813, -0.4322, -2.7928, 6.2357, 0.7219, -3.0239, 6.2249, 0.9948, -3.4943, 6.2142, 0.8152, -3.2178, 6.2034, 0.4776, -3.7493, 5.8155, -0.0479, -2.1093, 5.6012, -2.4696, 0.1281, 5.7604, -2.3990, -0.1975, 5.8466, 0.5866, -2.1883, 5.4037, 3.2070, -1.8543, 4.9656, -1.0068, -0.9732, 5.1368, -4.0785, -1.9944, 5.2433, -5.2864, -2.7007, 5.3343, -5.9113, -2.4505, 4.8949, -3.0406, -1.6963, 4.4173, -4.0378, -0.4920, 4.5574, -7.0330, -1.5670, 4.4796, -7.8051, -2.4900, 4.4041, -8.5629, -2.8790, 4.0677, -8.0828, -2.2194, 4.0510, -7.6088, -1.3874, 3.5087, -5.8359, -0.9098, 3.2429, -8.8478, -0.6668, 3.3555, -11.9016, -1.3132, 3.3962, -14.0037, -0.5303, 3.4201, -12.9730, 0.1317, 3.5314, -9.8569, -0.5064, 3.4752, -10.3274, 0.5997
};

int raw_feature_get_data(size_t offset, size_t length, float *out_ptr) {
    memcpy(out_ptr, features + offset, length * sizeof(float));
    return 0;
}

int main() {
    // This is needed so that output of printf is output immediately 
    setvbuf(stdout, NULL, _IONBF, 0);

    printk("Edge Impulse standalone inferencing (Zephyr)\n");

    if (sizeof(features) / sizeof(float) != EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE) {
        printk("The size of your 'features' array is not correct. Expected %d items, but had %u\n",
            EI_CLASSIFIER_DSP_INPUT_FRAME_SIZE, sizeof(features) / sizeof(float));
        return 1;
    }

    ei_impulse_result_t result = { 0 };

    while (1) {
        // the features are stored into flash, and we don't want to load everything into RAM
        signal_t features_signal;
        features_signal.total_length = sizeof(features) / sizeof(features[0]);
        features_signal.get_data = &raw_feature_get_data;

        // invoke the impulse
        EI_IMPULSE_ERROR res = run_classifier(&features_signal, &result, true);
        printk("run_classifier returned: %d\n", res);

        if (res != 0) return 1;

        printk("Predictions (DSP: %d ms., Classification: %d ms., Anomaly: %d ms.): \n",
            result.timing.dsp, result.timing.classification, result.timing.anomaly);

        // print the predictions
        printk("[");
        for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
            ei_printf_float(result.classification[ix].value);
#if EI_CLASSIFIER_HAS_ANOMALY == 1
            printk(", ");
#else
            if (ix != EI_CLASSIFIER_LABEL_COUNT - 1) {
                printk(", ");
            }
#endif
        }
#if EI_CLASSIFIER_HAS_ANOMALY == 1
        ei_printf_float(result.anomaly);
#endif
        printk("]\n");

        k_msleep(2000);
    }
}
